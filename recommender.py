# -*- coding: utf-8 -*-
"""recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mg4kLTwHtwOqVuJdQrfVVvPVLVmJ04DJ
"""

import pandas as pd

# Load the data
ratings = pd.read_csv('/content/data/ratings.csv')
movies = pd.read_csv('/content/data/movies.csv')

# Display the first few rows
print(ratings.head())
print(movies.head())

# Create a user-item matrix
user_item_matrix = ratings.pivot(index='userId', columns='movieId', values='rating')

# Fill missing values with 0 (no rating)
user_item_matrix = user_item_matrix.fillna(0)

print(user_item_matrix.head())

import numpy as np

# Define the number of latent factors
num_factors = 10

# Initialize user and item matrices with random values
num_users, num_items = user_item_matrix.shape
user_matrix = np.random.rand(num_users, num_factors)
item_matrix = np.random.rand(num_items, num_factors)

# Define a function to perform matrix factorization
def matrix_factorization(R, P, Q, steps=100, alpha=0.0002, beta=0.02):
    for step in range(steps):
        for i in range(R.shape[0]):
            for j in range(R.shape[1]):
                if R[i][j] > 0:
                    # Calculate the error
                    eij = R[i][j] - np.dot(P[i, :], Q[j, :].T)
                    # Update user and item matrices
                    P[i, :] += alpha * (2 * eij * Q[j, :] - beta * P[i, :])
                    Q[j, :] += alpha * (2 * eij * P[i, :] - beta * Q[j, :])
        # Calculate total error
        error = 0
        for i in range(R.shape[0]):
            for j in range(R.shape[1]):
                if R[i][j] > 0:
                    error += (R[i][j] - np.dot(P[i, :], Q[j, :].T)) ** 2
                    error += (beta / 2) * (np.sum(P[i, :] ** 2) + np.sum(Q[j, :] ** 2))
        if error < 0.001:
            break
    return P, Q

# Perform matrix factorization
user_matrix, item_matrix = matrix_factorization(user_item_matrix.values, user_matrix, item_matrix)

def recommend_movies(user_id, user_matrix, item_matrix, movies, top_n=5):
    # Predict ratings for all movies
    predicted_ratings = np.dot(user_matrix[user_id - 1], item_matrix.T)

    # Get the top N movie IDs
    top_movie_ids = np.argsort(predicted_ratings)[-top_n:][::-1]

    # Map movie IDs to titles
    recommendations = movies[movies['movieId'].isin(top_movie_ids)]
    return recommendations

# Example: Recommend movies for user 1
user_id = 609

recommendations = recommend_movies(user_id, user_matrix, item_matrix, movies)
print(f"Top recommendations for user {user_id}:")
print(recommendations)

from sklearn.metrics import mean_squared_error

# Calculate predicted ratings
predicted_matrix = np.dot(user_matrix, item_matrix.T)

# Flatten the matrices for comparison
actual_ratings = user_item_matrix.values.flatten()
predicted_ratings = predicted_matrix.flatten()

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(actual_ratings, predicted_ratings))
print(f"RMSE: {rmse}")